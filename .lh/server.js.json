{
    "sourceFile": "server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1760431595180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760431745485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -314,26 +314,34 @@\n     }\r\n     \r\n     const user = result.rows[0];\r\n     \r\n-    // Verify password (handle both hashed and plain text passwords)\r\n+    // Verify password (handle bcrypt hashed, base64 encoded, and plain text passwords)\r\n     let isPasswordValid = false;\r\n     \r\n-    // First try bcrypt comparison (for hashed passwords)\r\n-    try {\r\n-      isPasswordValid = await bcrypt.compare(password, user.password_hash);\r\n-    } catch (bcryptError) {\r\n-      // If bcrypt fails, it might be a plain text password\r\n-      console.log('[POST /api/login] bcrypt failed, trying plain text comparison');\r\n-      isPasswordValid = (password === user.password_hash);\r\n+    // First try bcrypt comparison (for hashed passwords starting with $2b$)\r\n+    if (user.password_hash.startsWith('$2b$')) {\r\n+      try {\r\n+        isPasswordValid = await bcrypt.compare(password, user.password_hash);\r\n+        console.log('[POST /api/login] using bcrypt verification');\r\n+      } catch (bcryptError) {\r\n+        console.log('[POST /api/login] bcrypt error:', bcryptError.message);\r\n+        isPasswordValid = false;\r\n+      }\r\n+    } else {\r\n+      // Try base64 decoding first (for legacy base64 encoded passwords)\r\n+      try {\r\n+        const decodedPassword = Buffer.from(user.password_hash, 'base64').toString();\r\n+        isPasswordValid = (password === decodedPassword);\r\n+        console.log('[POST /api/login] using base64 decoding verification');\r\n+      } catch (base64Error) {\r\n+        // If base64 fails, try plain text comparison\r\n+        console.log('[POST /api/login] base64 failed, trying plain text comparison');\r\n+        isPasswordValid = (password === user.password_hash);\r\n+      }\r\n     }\r\n     \r\n-    // If bcrypt succeeded but returned false, also try plain text comparison\r\n     if (!isPasswordValid) {\r\n-      isPasswordValid = (password === user.password_hash);\r\n-    }\r\n-    \r\n-    if (!isPasswordValid) {\r\n       console.warn('[POST /api/login] invalid password for:', email);\r\n       return res.status(401).json({ \r\n         success: false, \r\n         error: 'Invalid email or password.' \r\n"
                },
                {
                    "date": 1760433095966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -422,5 +422,14 @@\n   console.error('Failed to connect to PostgreSQL:', err.message);\r\n   start(); // still start to expose health endpoint with error state\r\n });\r\n \r\n+// Handle uncaught errors to prevent server from crashing\r\n+process.on('uncaughtException', (err) => {\r\n+  console.error('Uncaught Exception:', err);\r\n+});\r\n+\r\n+process.on('unhandledRejection', (reason, promise) => {\r\n+  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\r\n+});\r\n+\r\n export default app;\r\n"
                },
                {
                    "date": 1760435428070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,11 +20,15 @@\n     'http://localhost:8080',\r\n     'http://127.0.0.1:8080',\r\n     'http://localhost:5173',\r\n     'http://127.0.0.1:5173',\r\n-    // Allow Vite dev server at 5174 as per current app URL\r\n+    // Allow Vite dev server at 5174, 5175, 5176\r\n     'http://localhost:5174',\r\n-    'http://127.0.0.1:5174'\r\n+    'http://127.0.0.1:5174',\r\n+    'http://localhost:5175',\r\n+    'http://127.0.0.1:5175',\r\n+    'http://localhost:5176',\r\n+    'http://127.0.0.1:5176'\r\n   ],\r\n   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\r\n   allowedHeaders: ['Content-Type', 'Authorization'],\r\n   credentials: true,\r\n"
                },
                {
                    "date": 1760955672655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,39 +1,27 @@\n import express from 'express';\r\n import cors from 'cors';\r\n-import pg from 'pg';\r\n import bcrypt from 'bcryptjs';\r\n+import dbConfig from './config/database.js';\r\n import dbRoutes from './routes/db-routes.js';\r\n import zoneRoutes from './routes/zone-routes.js';\r\n-const { Pool } = pg;\r\n \r\n-// Configuration (could move to .env later)\r\n-// Primary server configuration per user request - configured for consistent saving\r\n+// Use the shared pool from centralized config\r\n+const { pool, corsConfig } = dbConfig;\r\n+\r\n+// Configuration from .env file\r\n const PORT = process.env.PORT || 3101;\r\n-const HOST = '127.0.0.1';\r\n-const CONNECTION_STRING = 'postgres://postgres:NewStrongPass123@localhost:5432/mapit';\r\n+const HOST = dbConfig.db.host || '127.0.0.1';\r\n \r\n const app = express();\r\n \r\n-// Enable CORS for all routes\r\n+// Enable CORS for all routes using config\r\n app.use(cors({\r\n-  origin: [\r\n-    'http://localhost:8080',\r\n-    'http://127.0.0.1:8080',\r\n-    'http://localhost:5173',\r\n-    'http://127.0.0.1:5173',\r\n-    // Allow Vite dev server at 5174, 5175, 5176\r\n-    'http://localhost:5174',\r\n-    'http://127.0.0.1:5174',\r\n-    'http://localhost:5175',\r\n-    'http://127.0.0.1:5175',\r\n-    'http://localhost:5176',\r\n-    'http://127.0.0.1:5176'\r\n-  ],\r\n+  origin: corsConfig.origins,\r\n   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\r\n   allowedHeaders: ['Content-Type', 'Authorization'],\r\n   credentials: true,\r\n-  maxAge: 86400\r\n+  maxAge: corsConfig.maxAge\r\n }));\r\n app.use(express.json());\r\n app.use(express.static('public'));\r\n \r\n@@ -56,9 +44,9 @@\n   }\r\n   next();\r\n });\r\n \r\n-const pool = new Pool({ connectionString: CONNECTION_STRING });\r\n+// Pool is already imported from config/database.js - no need to create new one\r\n \r\n function hashPassword(plain) {\r\n   try {\r\n     return bcrypt.hashSync(plain, 10);\r\n@@ -182,14 +170,15 @@\n       customer_id\r\n     ]);\r\n     \r\n     const map_id = result.rows[0]?.map_id;\r\n-    \r\n+\r\n     console.log('[POST /api/map] created map with ID:', map_id);\r\n-    \r\n+\r\n+    // Return using `map` key so the frontend (NewMapForm) finds `result.map.map_id`\r\n     return res.status(201).json({\r\n       success: true,\r\n-      record: {\r\n+      map: {\r\n         map_id,\r\n         title,\r\n         description,\r\n         map_code: map_code || null\r\n@@ -289,8 +278,68 @@\n     });\r\n   }\r\n });\r\n \r\n+// Get a single map by ID\r\n+app.get('/api/map/:map_id', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  const map_id = req.params.map_id;\r\n+\r\n+  if (!map_id) {\r\n+    return res.status(400).json({ success: false, error: 'Map ID is required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const result = await pool.query(`\r\n+      SELECT map_id, title, description, map_code, customer_id, country, map_data, map_bounds, active, created_at\r\n+      FROM map\r\n+      WHERE map_id = $1\r\n+    `, [map_id]);\r\n+\r\n+    if (result.rows.length === 0) {\r\n+      return res.status(404).json({ success: false, error: 'Map not found.' });\r\n+    }\r\n+\r\n+    return res.json({ success: true, map: result.rows[0] });\r\n+  } catch (err) {\r\n+    console.error(`[GET /api/map/${map_id}] error:`, err);\r\n+    return res.status(500).json({ success: false, error: err && err.message ? err.message : 'Failed to fetch map.' });\r\n+  }\r\n+});\r\n+\r\n+// Delete a map (and its zones and customer_map relations)\r\n+app.delete('/api/map/:map_id', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  const { map_id } = req.params;\r\n+\r\n+  console.log(`[DELETE /api/map/${map_id}] Deleting map and related records`);\r\n+\r\n+  if (!map_id) {\r\n+    return res.status(400).json({ success: false, error: 'Map ID is required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    // Delete zones that belong to this map\r\n+    await pool.query(`DELETE FROM zones WHERE map_id = $1`, [map_id]);\r\n+\r\n+    // Delete customer_map relationships\r\n+    await pool.query(`DELETE FROM customer_map WHERE map_id = $1`, [map_id]);\r\n+\r\n+    // Delete the map itself\r\n+    const result = await pool.query(`DELETE FROM map WHERE map_id = $1 RETURNING map_id`, [map_id]);\r\n+\r\n+    if (result.rows.length === 0) {\r\n+      return res.status(404).json({ success: false, error: 'Map not found.' });\r\n+    }\r\n+\r\n+    console.log(`[DELETE /api/map/${map_id}] Deleted map successfully`);\r\n+    return res.json({ success: true, message: 'Map deleted successfully.' });\r\n+  } catch (err) {\r\n+    console.error(`[DELETE /api/map/${map_id}] error:`, err);\r\n+    return res.status(500).json({ success: false, error: err && err.message ? err.message : 'Failed to delete map.' });\r\n+  }\r\n+});\r\n+\r\n app.post('/api/login', async (req, res) => {\r\n   res.setHeader('Content-Type', 'application/json');\r\n   const { email, password } = req.body ?? {};\r\n   console.log('[POST /api/login] attempting login for:', email);\r\n@@ -317,31 +366,34 @@\n       });\r\n     }\r\n     \r\n     const user = result.rows[0];\r\n-    \r\n+\r\n     // Verify password (handle bcrypt hashed, base64 encoded, and plain text passwords)\r\n     let isPasswordValid = false;\r\n-    \r\n+\r\n+    // Defensively handle missing or non-string password_hash to avoid runtime errors\r\n+    const pwdHash = (user && typeof user.password_hash === 'string') ? user.password_hash : '';\r\n+\r\n     // First try bcrypt comparison (for hashed passwords starting with $2b$)\r\n-    if (user.password_hash.startsWith('$2b$')) {\r\n+    if (pwdHash.startsWith('$2b$')) {\r\n       try {\r\n-        isPasswordValid = await bcrypt.compare(password, user.password_hash);\r\n+        isPasswordValid = await bcrypt.compare(password, pwdHash);\r\n         console.log('[POST /api/login] using bcrypt verification');\r\n       } catch (bcryptError) {\r\n         console.log('[POST /api/login] bcrypt error:', bcryptError.message);\r\n         isPasswordValid = false;\r\n       }\r\n     } else {\r\n       // Try base64 decoding first (for legacy base64 encoded passwords)\r\n       try {\r\n-        const decodedPassword = Buffer.from(user.password_hash, 'base64').toString();\r\n+        const decodedPassword = pwdHash ? Buffer.from(pwdHash, 'base64').toString() : '';\r\n         isPasswordValid = (password === decodedPassword);\r\n         console.log('[POST /api/login] using base64 decoding verification');\r\n       } catch (base64Error) {\r\n         // If base64 fails, try plain text comparison\r\n         console.log('[POST /api/login] base64 failed, trying plain text comparison');\r\n-        isPasswordValid = (password === user.password_hash);\r\n+        isPasswordValid = (password === pwdHash);\r\n       }\r\n     }\r\n     \r\n     if (!isPasswordValid) {\r\n@@ -372,8 +424,54 @@\n     });\r\n   }\r\n });\r\n \r\n+// Get maps for a specific customer with zone counts\r\n+app.get('/api/customer/:customer_id/maps', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  const { customer_id } = req.params;\r\n+  \r\n+  if (!customer_id) {\r\n+    return res.status(400).json({ \r\n+      success: false, \r\n+      error: 'Customer ID is required.' \r\n+    });\r\n+  }\r\n+  \r\n+  try {\r\n+    // Get all maps for this customer with zone counts\r\n+    const result = await pool.query(`\r\n+      SELECT \r\n+        m.map_id,\r\n+        m.title,\r\n+        m.description,\r\n+        m.map_code,\r\n+        m.created_at,\r\n+        m.active,\r\n+        m.country,\r\n+        COUNT(z.id) as zone_count\r\n+      FROM map m\r\n+      LEFT JOIN zones z ON m.map_id = z.map_id\r\n+      WHERE m.customer_id = $1\r\n+      GROUP BY m.map_id, m.title, m.description, m.map_code, m.created_at, m.active, m.country\r\n+      ORDER BY m.created_at DESC;\r\n+    `, [customer_id]);\r\n+    \r\n+    console.log(`[GET /api/customer/${customer_id}/maps] Found ${result.rows.length} maps`);\r\n+    \r\n+    return res.json({\r\n+      success: true,\r\n+      maps: result.rows\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(`[GET /api/customer/${customer_id}/maps] error:`, err);\r\n+    return res.status(500).json({\r\n+      success: false,\r\n+      error: err && typeof err === 'object' && 'message' in err ? err.message : 'Failed to fetch maps.'\r\n+    });\r\n+  }\r\n+});\r\n+\r\n // Add database routes\r\n app.use('/api/db', dbRoutes);\r\n \r\n // Add zone management routes\r\n"
                },
                {
                    "date": 1760955871679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,10 @@\n import dbRoutes from './routes/db-routes.js';\r\n import zoneRoutes from './routes/zone-routes.js';\r\n \r\n // Use the shared pool from centralized config\r\n-const { pool, corsConfig } = dbConfig;\r\n+const pool = dbConfig.pool;\r\n+const corsConfig = dbConfig.cors;\r\n \r\n // Configuration from .env file\r\n const PORT = process.env.PORT || 3101;\r\n const HOST = dbConfig.db.host || '127.0.0.1';\r\n"
                },
                {
                    "date": 1761127556657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,8 +425,175 @@\n     });\r\n   }\r\n });\r\n \r\n+// Admin login route\r\n+app.post('/api/admin/login', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  const { email, password } = req.body ?? {};\r\n+  console.log('[POST /api/admin/login] attempting admin login for:', email);\r\n+  \r\n+  if (!email || !password) {\r\n+    return res.status(400).json({ \r\n+      success: false, \r\n+      error: 'Email and password are required.' \r\n+    });\r\n+  }\r\n+  \r\n+  try {\r\n+    // Find admin by email\r\n+    const result = await pool.query(\r\n+      'SELECT admin_id, email, first_name, last_name, password_hash FROM admin WHERE email = $1',\r\n+      [email.toLowerCase().trim()]\r\n+    );\r\n+    \r\n+    if (result.rows.length === 0) {\r\n+      console.warn('[POST /api/admin/login] no admin found with email:', email);\r\n+      return res.status(401).json({ \r\n+        success: false, \r\n+        error: 'Invalid admin credentials.' \r\n+      });\r\n+    }\r\n+    \r\n+    const admin = result.rows[0];\r\n+\r\n+    // Verify password using bcrypt\r\n+    let isPasswordValid = false;\r\n+    const pwdHash = (admin && typeof admin.password_hash === 'string') ? admin.password_hash : '';\r\n+\r\n+    if (pwdHash.startsWith('$2b$')) {\r\n+      try {\r\n+        isPasswordValid = await bcrypt.compare(password, pwdHash);\r\n+        console.log('[POST /api/admin/login] using bcrypt verification');\r\n+      } catch (bcryptError) {\r\n+        console.log('[POST /api/admin/login] bcrypt error:', bcryptError.message);\r\n+        isPasswordValid = false;\r\n+      }\r\n+    }\r\n+    \r\n+    if (!isPasswordValid) {\r\n+      console.warn('[POST /api/admin/login] invalid password for:', email);\r\n+      return res.status(401).json({ \r\n+        success: false, \r\n+        error: 'Invalid admin credentials.' \r\n+      });\r\n+    }\r\n+    \r\n+    // Update last login timestamp\r\n+    await pool.query(\r\n+      'UPDATE admin SET last_login = NOW() WHERE admin_id = $1',\r\n+      [admin.admin_id]\r\n+    );\r\n+    \r\n+    // Return admin data (excluding password_hash)\r\n+    console.log('[POST /api/admin/login] successful login for:', email);\r\n+    return res.json({\r\n+      success: true,\r\n+      admin: {\r\n+        admin_id: admin.admin_id,\r\n+        email: admin.email,\r\n+        first_name: admin.first_name,\r\n+        last_name: admin.last_name\r\n+      }\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('[POST /api/admin/login] error:', err);\r\n+    const message = err && typeof err === 'object' && 'message' in err ? err.message : 'Admin login failed.';\r\n+    return res.status(500).json({ \r\n+      success: false, \r\n+      error: message \r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// Get all maps with customer information (admin only)\r\n+app.get('/api/admin/maps', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  \r\n+  try {\r\n+    // Get all maps with customer information and zone counts\r\n+    const result = await pool.query(`\r\n+      SELECT \r\n+        m.map_id,\r\n+        m.title,\r\n+        m.description,\r\n+        m.map_code,\r\n+        m.created_at,\r\n+        m.active,\r\n+        m.country,\r\n+        m.customer_id,\r\n+        c.first_name,\r\n+        c.last_name,\r\n+        c.email,\r\n+        c.registration_date,\r\n+        COUNT(z.id) as zone_count\r\n+      FROM map m\r\n+      LEFT JOIN customer c ON m.customer_id = c.customer_id\r\n+      LEFT JOIN zones z ON m.map_id = z.map_id\r\n+      GROUP BY m.map_id, m.title, m.description, m.map_code, m.created_at, m.active, m.country, \r\n+               m.customer_id, c.first_name, c.last_name, c.email, c.registration_date\r\n+      ORDER BY m.created_at DESC;\r\n+    `);\r\n+    \r\n+    console.log(`[GET /api/admin/maps] Found ${result.rows.length} maps`);\r\n+    \r\n+    return res.json({\r\n+      success: true,\r\n+      maps: result.rows,\r\n+      total: result.rows.length\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('[GET /api/admin/maps] error:', err);\r\n+    return res.status(500).json({\r\n+      success: false,\r\n+      error: err && typeof err === 'object' && 'message' in err ? err.message : 'Failed to fetch maps.'\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// Get dashboard statistics (admin only)\r\n+app.get('/api/admin/stats', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  \r\n+  try {\r\n+    // Get various statistics\r\n+    const statsQueries = await Promise.all([\r\n+      pool.query('SELECT COUNT(*) as total FROM map'),\r\n+      pool.query('SELECT COUNT(*) as total FROM customer'),\r\n+      pool.query('SELECT COUNT(*) as total FROM zones'),\r\n+      pool.query('SELECT COUNT(*) as total FROM map WHERE active = true'),\r\n+      pool.query(`\r\n+        SELECT DATE(created_at) as date, COUNT(*) as count \r\n+        FROM map \r\n+        WHERE created_at >= NOW() - INTERVAL '30 days'\r\n+        GROUP BY DATE(created_at)\r\n+        ORDER BY date DESC\r\n+      `)\r\n+    ]);\r\n+    \r\n+    const stats = {\r\n+      totalMaps: parseInt(statsQueries[0].rows[0].total),\r\n+      totalCustomers: parseInt(statsQueries[1].rows[0].total),\r\n+      totalZones: parseInt(statsQueries[2].rows[0].total),\r\n+      activeMaps: parseInt(statsQueries[3].rows[0].total),\r\n+      recentActivity: statsQueries[4].rows\r\n+    };\r\n+    \r\n+    console.log('[GET /api/admin/stats] Statistics retrieved');\r\n+    \r\n+    return res.json({\r\n+      success: true,\r\n+      stats\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('[GET /api/admin/stats] error:', err);\r\n+    return res.status(500).json({\r\n+      success: false,\r\n+      error: err && typeof err === 'object' && 'message' in err ? err.message : 'Failed to fetch statistics.'\r\n+    });\r\n+  }\r\n+});\r\n+\r\n // Get maps for a specific customer with zone counts\r\n app.get('/api/customer/:customer_id/maps', async (req, res) => {\r\n   res.setHeader('Content-Type', 'application/json');\r\n   const { customer_id } = req.params;\r\n"
                },
                {
                    "date": 1761130551692,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -306,8 +306,42 @@\n     return res.status(500).json({ success: false, error: err && err.message ? err.message : 'Failed to fetch map.' });\r\n   }\r\n });\r\n \r\n+// Get zones for a specific map\r\n+app.get('/api/map/:id/zones', async (req, res) => {\r\n+  res.setHeader('Content-Type', 'application/json');\r\n+  const { id } = req.params;\r\n+\r\n+  console.log(`[GET /api/map/${id}/zones] Fetching zones for map`);\r\n+\r\n+  if (!id) {\r\n+    return res.status(400).json({ success: false, error: 'Map ID is required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const result = await pool.query(`\r\n+      SELECT zone_id, map_id, name, color, coordinates, created_at\r\n+      FROM zones\r\n+      WHERE map_id = $1\r\n+      ORDER BY created_at ASC\r\n+    `, [id]);\r\n+\r\n+    console.log(`[GET /api/map/${id}/zones] Found ${result.rows.length} zones`);\r\n+\r\n+    return res.json({ \r\n+      success: true, \r\n+      zones: result.rows \r\n+    });\r\n+  } catch (err) {\r\n+    console.error(`[GET /api/map/${id}/zones] error:`, err);\r\n+    return res.status(500).json({ \r\n+      success: false, \r\n+      error: err && err.message ? err.message : 'Failed to fetch zones.' \r\n+    });\r\n+  }\r\n+});\r\n+\r\n // Delete a map (and its zones and customer_map relations)\r\n app.delete('/api/map/:map_id', async (req, res) => {\r\n   res.setHeader('Content-Type', 'application/json');\r\n   const { map_id } = req.params;\r\n"
                },
                {
                    "date": 1761130799559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -319,9 +319,9 @@\n   }\r\n \r\n   try {\r\n     const result = await pool.query(`\r\n-      SELECT zone_id, map_id, name, color, coordinates, created_at\r\n+      SELECT id, map_id, name, color, coordinates, created_at\r\n       FROM zones\r\n       WHERE map_id = $1\r\n       ORDER BY created_at ASC\r\n     `, [id]);\r\n"
                }
            ],
            "date": 1760431595180,
            "name": "Commit-0",
            "content": "import express from 'express';\r\nimport cors from 'cors';\r\nimport pg from 'pg';\r\nimport bcrypt from 'bcryptjs';\r\nimport dbRoutes from './routes/db-routes.js';\r\nimport zoneRoutes from './routes/zone-routes.js';\r\nconst { Pool } = pg;\r\n\r\n// Configuration (could move to .env later)\r\n// Primary server configuration per user request - configured for consistent saving\r\nconst PORT = process.env.PORT || 3101;\r\nconst HOST = '127.0.0.1';\r\nconst CONNECTION_STRING = 'postgres://postgres:NewStrongPass123@localhost:5432/mapit';\r\n\r\nconst app = express();\r\n\r\n// Enable CORS for all routes\r\napp.use(cors({\r\n  origin: [\r\n    'http://localhost:8080',\r\n    'http://127.0.0.1:8080',\r\n    'http://localhost:5173',\r\n    'http://127.0.0.1:5173',\r\n    // Allow Vite dev server at 5174 as per current app URL\r\n    'http://localhost:5174',\r\n    'http://127.0.0.1:5174'\r\n  ],\r\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\r\n  allowedHeaders: ['Content-Type', 'Authorization'],\r\n  credentials: true,\r\n  maxAge: 86400\r\n}));\r\napp.use(express.json());\r\napp.use(express.static('public'));\r\n\r\n// Handle invalid JSON bodies explicitly so frontend gets JSON instead of HTML\r\napp.use((err, _req, res, next) => {\r\n  if (err instanceof SyntaxError && 'status' in err) {\r\n    console.error('[BodyParser] Invalid JSON:', err.message);\r\n    return res.status(400).json({ success: false, error: 'Invalid JSON payload' });\r\n  }\r\n  next(err);\r\n});\r\n\r\n// Universal request logger (after body parse / invalid JSON handler)\r\napp.use((req, _res, next) => {\r\n  if (req.path.startsWith('/api/')) {\r\n    console.log(`[REQ] ${req.method} ${req.path} content-type=${req.headers['content-type'] || ''}`);\r\n    if (req.method !== 'GET') {\r\n      console.log('[REQ BODY]', req.body);\r\n    }\r\n  }\r\n  next();\r\n});\r\n\r\nconst pool = new Pool({ connectionString: CONNECTION_STRING });\r\n\r\nfunction hashPassword(plain) {\r\n  try {\r\n    return bcrypt.hashSync(plain, 10);\r\n  } catch (e) {\r\n    console.error('[hashPassword] bcrypt failed, falling back to base64:', e?.message || e);\r\n    return Buffer.from(plain).toString('base64');\r\n  }\r\n}\r\n\r\n// Health / info routes\r\napp.get('/api/health', async (_req, res) => {\r\n  try {\r\n    const r = await pool.query('SELECT NOW() as now');\r\n    res.json({ status: 'ok', time: r.rows[0].now });\r\n  } catch (e) {\r\n    const message = e && typeof e === 'object' && 'message' in e ? e.message : 'Unknown error';\r\n    res.status(500).json({ status: 'error', error: message });\r\n  }\r\n});\r\n\r\napp.get('/api/test', (_req, res) => {\r\n  res.json({ message: 'Server is working!' });\r\n});\r\n\r\n// Diagnostic echo route\r\napp.post('/api/echo', (req, res) => {\r\n  res.json({ success: true, received: req.body });\r\n});\r\n\r\n// Registration route\r\napp.post('/api/register', async (req, res) => {\r\n  res.setHeader('Content-Type', 'application/json');\r\n  const { first_name, last_name, email, password } = req.body ?? {};\r\n  console.log('[POST /api/register] incoming body:', req.body);\r\n  if (!first_name || !last_name || !email || !password) {\r\n    return res.status(400).json({ success: false, error: 'All fields (first_name, last_name, email, password) are required.' });\r\n  }\r\n  try {\r\n    // Use synchronous bcrypt hash to avoid callback/promise mismatch\r\n  const password_hash = hashPassword(password);\r\n    const insertSql = `INSERT INTO customer (first_name, last_name, email, password_hash) VALUES ($1,$2,$3,$4)`;\r\n    await pool.query(insertSql, [\r\n      first_name.trim(),\r\n      last_name.trim(),\r\n      email.toLowerCase().trim(),\r\n      password_hash\r\n    ]);\r\n  console.log('[POST /api/register] inserted customer:', email.toLowerCase().trim());\r\n  const payload = { success: true, error: null };\r\n  console.log('[POST /api/register] response payload:', payload);\r\n  return res.status(201).json(payload);\r\n  } catch (err) {\r\n    if (err && typeof err === 'object' && 'code' in err && err.code === '23505') {\r\n      console.warn('[POST /api/register] duplicate email attempt:', email);\r\n      return res.status(409).json({ success: false, error: 'Email already registered.' });\r\n    }\r\n    console.error('[POST /api/register] unexpected error:', err);\r\n    const message = err && typeof err === 'object' && 'message' in err ? err.message : 'Failed to register user.';\r\n    return res.status(500).json({ success: false, error: message });\r\n  }\r\n});\r\n\r\n// Login route\r\n// Map creation endpoint\r\napp.post('/api/map', async (req, res) => {\r\n  res.setHeader('Content-Type', 'application/json');\r\n  const { title, description, map_data, map_bounds, active, country, map_code, customer_id } = req.body ?? {};\r\n  \r\n  console.log('[POST /api/map] creating map:', title);\r\n  console.log('[POST /api/map] customer_id:', customer_id);\r\n  \r\n  if (!title || !customer_id) {\r\n    return res.status(400).json({ \r\n      success: false, \r\n      error: 'Title and customer_id are required.' \r\n    });\r\n  }\r\n  \r\n  try {\r\n    // First, check if customer_id column exists in the map table\r\n    let columnExists = false;\r\n    try {\r\n      const columnCheck = await pool.query(`\r\n        SELECT column_name FROM information_schema.columns \r\n        WHERE table_name = 'map' AND column_name = 'customer_id'\r\n      `);\r\n      columnExists = columnCheck.rows.length > 0;\r\n    } catch (err) {\r\n      console.error('[POST /api/map] Error checking customer_id column:', err);\r\n    }\r\n    \r\n    // If column doesn't exist, add it\r\n    if (!columnExists) {\r\n      console.log('[POST /api/map] Adding customer_id column to map table');\r\n      try {\r\n        await pool.query(`\r\n          ALTER TABLE map ADD COLUMN customer_id INTEGER REFERENCES customer(customer_id)\r\n        `);\r\n        console.log('[POST /api/map] Successfully added customer_id column');\r\n      } catch (err) {\r\n        console.error('[POST /api/map] Error adding customer_id column:', err);\r\n        // Continue anyway, as the error might just be that another request already added the column\r\n      }\r\n    }\r\n    \r\n    // Insert map into database\r\n    const insertSql = `\r\n      INSERT INTO map (title, description, map_data, map_bounds, active, country, map_code, customer_id)\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n      RETURNING map_id\r\n    `;\r\n    \r\n    const result = await pool.query(insertSql, [\r\n      title,\r\n      description || null,\r\n      map_data || {},\r\n      map_bounds || {},\r\n      active !== undefined ? active : true,\r\n      country || null,\r\n      map_code || null,\r\n      customer_id\r\n    ]);\r\n    \r\n    const map_id = result.rows[0]?.map_id;\r\n    \r\n    console.log('[POST /api/map] created map with ID:', map_id);\r\n    \r\n    return res.status(201).json({\r\n      success: true,\r\n      record: {\r\n        map_id,\r\n        title,\r\n        description,\r\n        map_code: map_code || null\r\n      }\r\n    });\r\n  } catch (err) {\r\n    console.error('[POST /api/map] error:', err);\r\n    const message = err && typeof err === 'object' && 'message' in err \r\n      ? err.message \r\n      : 'Failed to create map.';\r\n    return res.status(500).json({ \r\n      success: false, \r\n      error: message \r\n    });\r\n  }\r\n});\r\n\r\n// Map update endpoint\r\napp.put('/api/map/:mapId', async (req, res) => {\r\n  res.setHeader('Content-Type', 'application/json');\r\n  const { title, description, map_data, map_bounds, active, country, map_codes, customer_id } = req.body ?? {};\r\n  const mapId = req.params.mapId;\r\n  \r\n  console.log('[PUT /api/map] updating map:', mapId);\r\n  console.log('[PUT /api/map] customer_id:', customer_id);\r\n  \r\n  if (!title || !customer_id || !mapId) {\r\n    return res.status(400).json({ \r\n      success: false, \r\n      error: 'Title, customer_id, and map_id are required.' \r\n    });\r\n  }\r\n  \r\n  try {\r\n    // Verify the map exists and belongs to this customer\r\n    const checkResult = await pool.query(\r\n      'SELECT map_id FROM map WHERE map_id = $1 AND customer_id = $2',\r\n      [mapId, customer_id]\r\n    );\r\n    \r\n    if (checkResult.rows.length === 0) {\r\n      console.log('[PUT /api/map] map not found or not owned by customer:', customer_id);\r\n      return res.status(404).json({ \r\n        success: false, \r\n        error: 'Map not found or you do not have permission to edit it.' \r\n      });\r\n    }\r\n    \r\n    // Update the map record\r\n    const updateSql = `\r\n      UPDATE map\r\n      SET title = $1, description = $2, map_data = $3, map_bounds = $4,\r\n          active = $5, country = $6, map_codes = $7, updated_at = NOW()\r\n      WHERE map_id = $8 AND customer_id = $9\r\n      RETURNING map_id\r\n    `;\r\n    \r\n    const result = await pool.query(updateSql, [\r\n      title,\r\n      description || null,\r\n      map_data || {},\r\n      map_bounds || {},\r\n      active !== undefined ? active : true,\r\n      country || null,\r\n      map_codes || [],\r\n      mapId,\r\n      customer_id\r\n    ]);\r\n    \r\n    if (result.rows.length === 0) {\r\n      console.log('[PUT /api/map] update failed, no rows affected');\r\n      return res.status(500).json({ \r\n        success: false, \r\n        error: 'Failed to update map.' \r\n      });\r\n    }\r\n    \r\n    console.log('[PUT /api/map] updated map with ID:', mapId);\r\n    \r\n    return res.status(200).json({\r\n      success: true,\r\n      record: {\r\n        map_id: mapId,\r\n        title,\r\n        description,\r\n        map_codes: map_codes || []\r\n      }\r\n    });\r\n  } catch (err) {\r\n    console.error('[PUT /api/map] error:', err);\r\n    const message = err && typeof err === 'object' && 'message' in err \r\n      ? err.message \r\n      : 'Failed to update map.';\r\n    return res.status(500).json({ \r\n      success: false, \r\n      error: message \r\n    });\r\n  }\r\n});\r\n\r\napp.post('/api/login', async (req, res) => {\r\n  res.setHeader('Content-Type', 'application/json');\r\n  const { email, password } = req.body ?? {};\r\n  console.log('[POST /api/login] attempting login for:', email);\r\n  \r\n  if (!email || !password) {\r\n    return res.status(400).json({ \r\n      success: false, \r\n      error: 'Email and password are required.' \r\n    });\r\n  }\r\n  \r\n  try {\r\n    // Find user by email\r\n    const result = await pool.query(\r\n      'SELECT customer_id, email, first_name, last_name, password_hash FROM customer WHERE email = $1',\r\n      [email.toLowerCase().trim()]\r\n    );\r\n    \r\n    if (result.rows.length === 0) {\r\n      console.warn('[POST /api/login] no user found with email:', email);\r\n      return res.status(401).json({ \r\n        success: false, \r\n        error: 'Invalid email or password.' \r\n      });\r\n    }\r\n    \r\n    const user = result.rows[0];\r\n    \r\n    // Verify password (handle both hashed and plain text passwords)\r\n    let isPasswordValid = false;\r\n    \r\n    // First try bcrypt comparison (for hashed passwords)\r\n    try {\r\n      isPasswordValid = await bcrypt.compare(password, user.password_hash);\r\n    } catch (bcryptError) {\r\n      // If bcrypt fails, it might be a plain text password\r\n      console.log('[POST /api/login] bcrypt failed, trying plain text comparison');\r\n      isPasswordValid = (password === user.password_hash);\r\n    }\r\n    \r\n    // If bcrypt succeeded but returned false, also try plain text comparison\r\n    if (!isPasswordValid) {\r\n      isPasswordValid = (password === user.password_hash);\r\n    }\r\n    \r\n    if (!isPasswordValid) {\r\n      console.warn('[POST /api/login] invalid password for:', email);\r\n      return res.status(401).json({ \r\n        success: false, \r\n        error: 'Invalid email or password.' \r\n      });\r\n    }\r\n    \r\n    // Return user data (excluding password_hash)\r\n    console.log('[POST /api/login] successful login for:', email);\r\n    return res.json({\r\n      success: true,\r\n      user: {\r\n        customer_id: user.customer_id,\r\n        email: user.email,\r\n        first_name: user.first_name,\r\n        last_name: user.last_name\r\n      }\r\n    });\r\n  } catch (err) {\r\n    console.error('[POST /api/login] error:', err);\r\n    const message = err && typeof err === 'object' && 'message' in err ? err.message : 'Login failed.';\r\n    return res.status(500).json({ \r\n      success: false, \r\n      error: message \r\n    });\r\n  }\r\n});\r\n\r\n// Add database routes\r\napp.use('/api/db', dbRoutes);\r\n\r\n// Add zone management routes\r\napp.use('/api/zones', zoneRoutes);\r\n\r\n// 404 handler (after defined routes, before error handler)\r\napp.use((req, res, next) => {\r\n  if (req.path.startsWith('/api/')) {\r\n    return res.status(404).json({ success: false, error: 'Not found' });\r\n  }\r\n  next();\r\n});\r\n\r\n// Central error handler (must have 4 args)\r\napp.use((err, _req, res, _next) => {\r\n  console.error('Unhandled server error:', err);\r\n  const message = err && typeof err === 'object' && 'message' in err ? err.message : 'Internal server error';\r\n  res.status(500).json({ success: false, error: message });\r\n});\r\n\r\n// Start server\r\nfunction start() {\r\n  // Use specified port 3100 for consistency with configuration\r\n  console.log(`Starting server on port ${PORT} (127.0.0.1)...`);\r\n  \r\n  const server = app.listen(PORT, HOST, () => {\r\n    console.log(`âœ… SUCCESS: API server running on http://${HOST}:${PORT}`);\r\n    console.log(`ðŸ“± For client access use: http://localhost:${PORT}`);\r\n  });\r\n  \r\n  server.on('error', (err) => {\r\n    console.error(`âŒ Error starting server on port ${PORT}:`, err.message);\r\n    \r\n    if (err.code === 'EADDRINUSE') {\r\n      console.error(`âŒ Port ${PORT} is already in use. Please free this port and try again.`);\r\n      console.error(`âŒ You can use 'netstat -ano | findstr ${PORT}' to find which process is using the port.`);\r\n      process.exit(1);\r\n    } else {\r\n      console.error('âŒ Failed to start server due to error:', err);\r\n      process.exit(1);\r\n    }\r\n  });\r\n}\r\n\r\n// Test DB connection first then start server\r\npool.query('SELECT 1').then(() => {\r\n  console.log('PostgreSQL connection successful');\r\n  start();\r\n}).catch(err => {\r\n  console.error('Failed to connect to PostgreSQL:', err.message);\r\n  start(); // still start to expose health endpoint with error state\r\n});\r\n\r\nexport default app;\r\n"
        }
    ]
}